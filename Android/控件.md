# 常用控件  
<br>
## 一、TextView  
android:id ----控件的Id  
android:layout_width----控件的宽度  
android:layout_height----控件的高度  
android:text----文本内容  
android:textSize----文本大小  
android:textColor----文本颜色  
android:background----控件背景  

xml布局文件：  
```
<TextView
        android:id="@+id/secondtext"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="#eeeeee"/>
```
## 二、EditText  
android:id----控件的Id   
android:layout_width----控件的宽度  
android:layout_height----控件的高度  
android:text----文本内容  
android:textSize----文本大小  
android:textColor----文本颜色  
android:background----控件背景  
android:hint----输入提示文本  
android:inputType----输入文本类型   

## 三、ImageView   
android:src="@drawable/ic_launcher"---ImageView的内容图像  
android:background="@drawable/ic_launcher"---ImageView背景图片  
android:background="#00ff00"---ImageView的RGB颜色  


## 四、Button和ImageButton
1. 共有特征  
(1)都可以作为一个按钮产生点击事件  
(2)都有background属性  
2. 不同点  
(1)Button有Text属性，ImageButton没有  
(2)ImageButton有src属性，Button没有  
3. src和background的区别：   
src是前景，图片会保持原来的尺寸不变形；backgrond是背景，图片会根据容器拉伸，亦可以使用颜色对其填充。   
两者可以同时使用  

## 五、文字处理  
所有控件的文字最好不要直接在xml中写，而是先把字符串按照一定格式写在res\values\strings.xml里面，然后在xml中通过字符串的id引用使用。  
例如：  
先在strings.xml中编辑  
`<string name="button_name">登陆</string>；`   
再在activity_main.xml中  
`android:text="@string/button_name"`来访问"登录"字符串。  

## 六、绑定监听事件  
1.Button和ImageButton都拥有一个onclik事件，通过自身的.setOnClickListener(OnClickListener)方法添加点击事件  
2.所有的控件都有一个onClick的事件，不仅仅Button和ImageButton拥有  
3.通过点击事件的监听可以实现点击按钮之后要发生什么动作  

监听事件实现的几种写法：    
1.匿名内部类的实现   
2.独立类的实现   
3.实现接口的方式来实现   

方式一：匿名内部类   
```java
loginButton.setOnClickListener(new OnClickListener(){
	public void OnClick(View arg0){
		//在当前onclick方法中监听动作
		system.out.println("我的按钮被点击了");//在控制台下输出一句话，则说明能间听到动作
	}
});
```   
方式二：独立类  
外部类监听点击事件：
```java
class MyOnclickListener implements OnClickListener{
	@Override
	public void onClick(View v) {
		Log.i("tag", "父类的onclick事件");
		v.setAlpha(0.5f);//设置按钮透明度。值在0~1之间。
	}
}
```  
主类中  
```java
private Button bt1;
bt1 = (Button) findViewById(R.id.button1);

//点击事件外部类的写法和作用
bt1.setOnClickListener(new MyOnclickListener(){
	@Override
	public void onClick(View v) {
		// TODO Auto-generated method stub
		//调用父类的onclick方法
		super.onClick(v);
		Toast.makeText(MainActivity.this, "bt1要执行的逻辑", 1).show();
	}
});
//使用外部类的好处：多个按钮同时用到同一功能可以只在父类中写一次即可实现，而不用分别监听每个按钮，减少代码冗余。
```

方式三：实现接口的方式来实现   
```java
public class MainActivity extends Activity implements OnClickListener{
	loginImageButton.setOnClickListener(this);
	public void onClick(View v) {
		// TODO Auto-generated method stub
		Log.i("tag","第三种方法");
	}
}
```

## 七、AutoCompleteTextView  
1. 作用：动态匹配输入内容
2. 独特属性：android:completionThreshold="2" //当输入两个字符时候进行匹配  
3. 使用：  
1.初始化控件：  
先声明`private AutoCompleteTextView acTextView;`  
然后初始化`acTextView=(AutoCompleteTextView)findViewBy(R.id.autoCompleteTextView1);`  
2.创建一个适配器，适配输入内容与数据源  
`ArrayAdapter<String> adapter = new ArrayAdapter<String>(content,resource,objects);`
其中：  
content——this,上下文的一个对象；   
resource——android.R.layout.simple_list_item_1(类似于activity_main的xml文件),对应的一个布局样式   
objects——（参数objects是String类型数组的数据源）   
3.初始化数据源（数据源中的内容去匹配文本框中输入的内容）   
`private String[ ] res = {"数据1","数据2","数据3","数据4",....};`  
把他及添加到adapder中去  
`ArrayAdapter<String> adapter =new ArrayAdapter<String>(this,android.R.layout.simple_list_item_1,res);`   
4.将adapter与当前AutoCompleteTextView控件进行绑定    
`acTextView.setAdapter(adapter);`   
5.在AutoCompleteTextView里面设置一条属性来使输入够3个字符开始匹配     
`android:completionThreshold = "3"`   

## 八、MultiAutoCompleteTextView 设置
第一步：初始化控件   
`macTextView =(MultiAutoCompleteTextView)findViewByID(R.id.multiAutoCompleteTextView);`   
第二步：需要一个适配器   
`ArrayAdapter<String> ad= new ArrayAdapter<String>(this, android.R.layout.simple_expandable_list_item_1, res);`   
第三步：初始化数据源——这数据源去匹配文本框输入的内容   
`private String []res={xxx,xxx,xxx,xxx,xxxxxx,xxxxxxx};`   
第四步：将adpter与当前AutoCompleteTextView绑定   
`macTextView.setAdapter(adapter);`    
第五步：设置分隔符     
`macTextView.setTokenizer(new MultiAutoCompleteTextView.CommaTokenizer());`   

## 九、ToggleButton  
- 什么是ToggleButton:   
按钮有两种状态：选中和未选中状态，处于不同的状态，按钮显示不同的文本。    
- ToggleButton属性：  
android:checked="true"  (初始状态)    
android:textoff="关"  
android:textOn="开"  
- ToggleButton的xml文件  
```xml
<ToggleButton 
android:id="@+id/toggleButton1"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:textOn="ON" //isChecked=true显示的text内容
android:textOff="OFF" //isChecked=false显示的text内容
android:checked="false"/>
```
- 实现ToggleButton的setOnCheckedChangeListener()方法   
```java
toggleButton = (ToggleButton) findViewById(R.id.toggleButton1);
toggleButton.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            @Override
            public void onCheckedChanged(CompoundButton compoundButton, boolean b) {
                if (b){
                    /*点击后为true，则执行该段代码*/
                    imageView.setBackgroundColor(Color.rgb(0,255,0));
                }else{
                    /*点击后为false，则执行该段代码*/
                    imageView.setBackgroundColor(Color.rgb(255,0,0));
                }
            }
});
```

## 十、CheckBox  
1. 两种状态 true和false    
2. 属性：  
andeoid:"@+id/checkbox"    
andeoid:layout_width="warp_content"   
andeoid:layout_height="warp_content"    
android:checked="false"   
android:text="男"   
3. 绑定监听器   
1.先实例一个CheckBox对象再初始化它   
`checkBox=(CheckBox)findViewById(R.id.checkBox);`   
2.然后通过设置CheckBox的监听事件来对其是否被选中做监听   
```java
checkBox.setOnCheckedChangeListener(new OnCheckedChangeListener(){
	public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
		//通过onCheckedChanged来监听当前的checkbox是否被选中
		if(isChecked){
			//获得checkbox的文本内容
			String text=checkBox.getText().toString();
			Log.i("tag", text);
		}
	}
});
```

## 十一、RadioGroup和RadioButton   
- 作用:实现多选一  
- 属性  
1.RadioGroup-->android:oritentation = "horizontal"/"vertical" //布局方向   
2.RadionButton-->android:checked = "true" //默认被选中    
- xml布局文件：  
```xml
<RadioGroup
        android:id="@+id/radiogroup"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content">
        <RadioButton
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:checked="true"
            android:text="男"/>
        <RadioButton
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="女"/>
</RadioGroup>
```
- 给RadioGroup增加监听  
```java
radioGroup = (RadioGroup) findViewById(R.id.radiogroup);
radioGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {
            @Override
            public void onCheckedChanged(RadioGroup radioGroup, int i) {
                if (i == R.id.radio0) {
                    Log.i("tag", "你是男孩");
                } else if (i == R.id.radio1) {
                    Log.i("tag", "你是女孩");
                }
            }
});
```   

## 十二、ListView   

- ListView作用：android系统中显示列表的控件，每一个ListView都可以包含很多个列表项。  
- 数据适配器：    
1.作用：把复杂的数据（数组、链表，数据库，集合等）填充在指定视图界面上。  
2.ArrayAdapter(数组适配器)：用于绑定格式单一的数据。数据源：可以是集合或数组  。
3.SimpleAdapter(简单适配器)：用于绑定格式复杂的数据。数据源：只能是特定泛型的集合。   
4.数据适配器是连接数据源和视图界面的桥梁。    
5.实现过程：新建适配器-->添加数据源到适配器-->视图加载适配器。    

- (ArrayAdapter)数据适配器的实现过程:   
1.新建适配器    
```java
private ArrayAdapter<String> arr_adapter;   
arr_adapter=new ArrayAdapter<String>(this,android.R.layout.simple_list_item_1,arr_data);  
//参数1：上下文。参数2：当前ListView加载的每一个列表项所对应的布局文件。参数3：数据源。   
```   
2.添加数据源到适配器   
`String[] arr_data={"1","2","3","4"};`   
3.视图(ListView)加载适配器    
`listView.setAdapter(arr_adapter);`    
- (SimpleAdapter)数据适配器的实现过程:    
1.新建适配器   
```java
private SimpleAdapter simp_adapter;   
simp_adapter=new SimpleAdapter<String>(context,data,resource,from,to);   
/**
*context:上下文(this)
*data:有特定泛型的集合数据源--一个Map所组成的List集合
*(新建自定义List<Map<String,Object>> dataList并通过方法返回在此处---详见笔记附录1)
*每一个Map都会去对应ListView列表中的一行
*每一个Map中的键必须包含所有在from中所指定的键>
*resource:列表项的布局文件ID(自定义布局)
*from:记录Map中的键名(new String[]{Map中的键})
*to:绑定数据视图中的ID,与from成对应关系(new int[]{布局文件中ID})
*/  
```    
2.添加数据源到适配器(上一步已包含)  
返回List的方法  
```java
private List<Map<String,Object>> getData(){
	for(int i=0;i<20;i++){
		Map<String,Object>map=new HashMap<String,Object>();
		map.put("pic",R.drawable.ic_launcher);
		map.put("text","慕课网"+i);
		dataList.add(map);
	}
	return dataList;
}
```   
3.视图(ListView)加载适配器    
`listView.setAdapter(simp_adapter);`   

- 示例：
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal">

    <ImageView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/imageView"
        android:src="@mipmap/ic_launcher"/>
    <TextView
        android:id="@+id/text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="40sp"
        android:hint="item"/>
</LinearLayout>
```
```java
public class MainActivity extends AppCompatActivity {

    private ListView listView;
    private SimpleAdapter simpleAdapter;
    private List<Map<String,Object>> dataList;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        listView = (ListView) findViewById(R.id.listView);
        dataList = new ArrayList<Map<String,Object>>();
        simpleAdapter = new SimpleAdapter(this,getData(),R.layout.item,new String[]{"pic","text"},new int[]{R.id.imageView,R.id.text});
        listView.setAdapter(simpleAdapter);
    }

    private List<Map<String,Object>> getData(){
        for (int i = 0; i < 20; i++){
            Map<String,Object> map = new HashMap<>();
            map.put("pic",R.mipmap.ic_launcher);
            map.put("text","列表"+i);
            dataList.add(map);
        }
        return dataList;
    }
}
```

- 绑定点击事件和滚动事件  
SCROLL_STATE_FLING -> 用户在手指离开屏幕之前，由于用力划了一下，视图任然依靠惯性，继续划了一段距离。    
SCROLL_STATE_IDLE -> 视图已经停止滑动。    
SCROLL_STATE_TOUCH_SCROLL -> 手指没有离开屏幕，手指正带着屏幕滑动。   
如果要动态修改数据，那么需要adapter.notifyDataSetChanged();如果修改了数据，而没有通知listview刷新，那么将会出错。     
```java
public class MainActivity extends AppCompatActivity implements AdapterView.OnItemClickListener,AbsListView.OnScrollListener {
    private ListView listView;
    private SimpleAdapter simpleAdapter;
    private List<Map<String,Object>> dataList;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        listView = (ListView) findViewById(R.id.listView);
        dataList = new ArrayList<Map<String,Object>>();
        simpleAdapter = new SimpleAdapter(this,getData(),R.layout.item,new String[]{"pic","text"},new int[]{R.id.imageView,R.id.text});
        listView.setAdapter(simpleAdapter);
        listView.setOnItemClickListener(this);
        listView.setOnScrollListener(this);

    }

    private List<Map<String,Object>> getData(){
        for (int i = 0; i < 20; i++){
            Map<String,Object> map = new HashMap<>();
            map.put("pic",R.mipmap.ic_launcher);
            map.put("text","列表"+i);
            dataList.add(map);
        }
        return dataList;
    }

    @Override
    public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
        String text = listView.getItemAtPosition(i)+"";
        Toast.makeText(this,"position=" + i + " text=" + text,Toast.LENGTH_LONG ).show();
    }

    @Override
    public void onScrollStateChanged(AbsListView absListView, int i) {
        switch (i){
            case SCROLL_STATE_FLING:
                Map<String,Object> map = new HashMap<>();
                map.put("pic",R.mipmap.ic_launcher);
                map.put("text","新添项");
                dataList.add(map);
                simpleAdapter.notifyDataSetChanged();
                break;
            case SCROLL_STATE_IDLE:
                break;
            case SCROLL_STATE_TOUCH_SCROLL:
                break;
        }

    }

    @Override
    public void onScroll(AbsListView absListView, int i, int i1, int i2) {

    }
}
```

## 十三、DatePicker和TimePicker
- month在机器中运行时是从0开始的，在sdk方法中使用一律采用不加1的方式，只有当用于显示时才手动加1；   
- 获取当前日期    
Calendar cal=Calendar.getInstance();   
- 获取当前日期及时间：   
int year=cal.get(Calendar.YEAR);   
int month=cal.get(Calendar.MONTH)+1;   
int day=cal.get(Calendar.DAY_OF_MONTH);   
int hour=cal.get(Calendar.HOUR_OF_DAY);   
int minute=cal.get(Calendar.MINUTE_OF_HOUR);   
setTitle(year+"-"+month+"-"+day+"-"+hour+":"+minute);    
- DataPicker初始化    
```java
datePicker.init(year,cal.get(Calendar.MONTH_OF_YEAR),day,new OnDateChangedListener(){//前三个是当前时间，最后监听器返回设置的值
	@Override
	public void onDateChanged(DatePicker view,int year,int monthOfYear，int dayOfMonth){
	setTitle(year+"-"+(monthOfYear+1)+"-"+dayOfMonth);
	}
});
```
- TimePicker    
时间选择器不需要手动初始化，默认初始化为当前的时间    
```java
TimePicker timePicker=(TimePicker)findViewById(R.id.timePicker1);   
timePicker.setOnTimeChangedListener(new OnTimeChangedListener(){
	@Override
	public void onTimeChanged(TimePicker view,int hourOfDay,int minute){
		setTitle(hourOfDay+"-"+minute);
	}
}
```    
示例：   
```java
public class MainActivity extends Activity {

	private DatePicker date_picker;
	private TimePicker time_picker;
	private TextView tv_date;
	private TextView tv_time;

	@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        //初始化
        date_picker=(DatePicker) findViewById(R.id.date);
        time_picker=(TimePicker) findViewById(R.id.time);
        tv_date=(TextView) findViewById(R.id.tv_date);
        tv_time=(TextView) findViewById(R.id.tv_time);
        //获取当前的年月日时分信息
        Calendar c=Calendar.getInstance();
        int year = c.get(Calendar.YEAR);
        int month=c.get(Calendar.MONTH);
        int day=c.get(Calendar.DAY_OF_MONTH);
        int hour=c.get(Calendar.HOUR_OF_DAY);
        int minute=c.get(Calendar.MINUTE);
        tv_date.setText("现在日期："+year+"-"+(month+1)+"-"+day);
        tv_time.setText("现在时间："+hour+":"+minute);
        //初始化日期
        date_picker.init(year, month, day, new OnDateChangedListener() {
			
			//监听日期的改变
        	@Override
			public void onDateChanged(DatePicker view, int year, int monthOfYear,
					int dayOfMonth) {
				// TODO Auto-generated method stub
				//Toast.makeText(MainActivity.this, "现在时间："+year+"-"+(monthOfYear+1)+"-"+dayOfMonth, 0).show();
			    tv_date.setText("现在日期："+year+"-"+(monthOfYear+1)+"-"+dayOfMonth);   
			}
		});
        
        //设置时间为24小时制
        time_picker.setIs24HourView(true);
        time_picker.setOnTimeChangedListener(new OnTimeChangedListener() {	
			@Override
			public void onTimeChanged(TimePicker view, int hourOfDay, int minute) {
				// TODO Auto-generated method stub
				tv_time.setText("现在时间："+hourOfDay+":"+minute);
			}
		});
 
    }
```
- DatePickerDialog
使用OnDateSetListener接口的onDateSet监听器调整了year，monthOfYear，dayOfMonth   
```java
new DatePickerDialog(this, new OnDateSetListener() {
	public void onDateSet(DatePicker view, int year, int monthOfYear,int dayOfMonth) {
		setTitle(year+"-"+(monthOfYear+1)+"-"+dayOfMonth);
	}
}, year, calendar.get(Calendar.MONTH), day).show();
//参数1：上下文。参数2：获取当前设置的时间。参数3-5：要设置的时间。
```
- TimePickerDialog    
使用OnTimeSetListener接口的onTimeSet监听器设置了hour,minute   
```java
new TimePickerDialog(this, new OnTimeSetListener() {
	public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
		setTitle(year+"-"+month+"-"+day+" "+hourOfDay+"-"+minute);
	}
}, hour, minute, true).show();//true为24小时制显示
```   
示例:   
```java
public class MainActivity extends Activity implements android.view.View.OnClickListener{

	private Button date_button;
	private Button time_button;
	private Calendar calendar;
	private TextView tv_date;
	private TextView tv_time;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.main);
        date_button=(Button) findViewById(R.id.date_button);
        time_button=(Button) findViewById(R.id.time_button);
        tv_date=(TextView) findViewById(R.id.tv_date);
        tv_time=(TextView) findViewById(R.id.tv_time);
        date_button.setOnClickListener(this);
        time_button.setOnClickListener(this);
        //获取当前的年月日时分信息
        calendar=Calendar.getInstance();
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		// Inflate the menu; this adds items to the action bar if it is present.
		getMenuInflater().inflate(R.menu.main, menu);
		return true;
	}
	
	private void showDateDialog()
	{
		DatePickerDialog date_dialog=new DatePickerDialog(MainActivity.this, new OnDateSetListener() {
			
			@Override
			public void onDateSet(DatePicker view, int year, int monthOfYear,
					int dayOfMonth) {
				// TODO Auto-generated method stub
				tv_date.setText("现在日期："+year+"-"+(monthOfYear+1)+"-"+dayOfMonth);
			}
		}, calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH));
		
		date_dialog.show();
	}
	
	private void showTimeDialog()
	{
		TimePickerDialog time_dialog=new TimePickerDialog(MainActivity.this, new OnTimeSetListener() {
			
			@Override
			public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
				// TODO Auto-generated method stub
				tv_time.setText("现在时间："+hourOfDay+":"+minute);
			}
		}, calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), true);
		time_dialog.show();
	}

	@Override
	public void onClick(View v) {
		// TODO Auto-generated method stub
		switch(v.getId())
		{
		  case R.id.date_button:
			  showDateDialog();
			  break;
		  case R.id.time_button:
			  showTimeDialog();
			  break;
		}
	}
```   

## 十四、GridView   
- 作用：用于在界面上按行、列分布的方式（表格）来显示多个组件；   
- 相似列表组件间比较：  
GridView 二维列表显示（行列式）   
ListView 一维行可下拉表显示（单调行表）  
- GridView的实现：  
数据源-->适配器-->视图界面   
- GridView的三个常用属性
android:numColumns="3" //每行显示多少列 自己也有一个属性auto_fit自动适应
android:horizontalSpacing="10dp"//列间距
android:verticalSpacing="10dp" //行间距
- GridView实现过程:  
1.准备数据源   
`private List<Map<String,Object>>dataList=new ArrayList<Map<String,Object>>();`    
2.新建适配器(SimpleAdapter)    
`SimpAdapter adapter=new SimpleAdapter(this,getData(),自定义布局,new String[]{"image","text"},new int[]{R.id.image,R.id.text});`    
```java     
getData方法 
private List<Map<String,Object>> getData(){
	for(int i=0;i<icon.length;i++){
		Map<String,Object>map=new HashMap<String,Object>();
		map.put("image",icon[i]);
		map.put("text",iconName[i]);
		dataList.add(map);
	}
	return dataList;
}
```
3.gridView加载适配器
`gridView.setAdapter(adapter);`       
4.配置监听器：
```java
implements OnItemclickListener(){};
gridView.setOnItemClickListener(this);
public void onItemClick(AapterView<?> parent,View view,int position,long id){
	Toast.makeText(this,"我是"+iconName[position],Toast.LENGTH_SHORT).show();
}
```   
- 示例：   
```java
public class MainActivity extends Activity {
	private GridView gridView;
	private SimpleAdapter adapter;
	private List<Map<String, Object>> dataList;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		setContentView(R.layout.main);
		gridView=(GridView) findViewById(R.id.gridView);
        dataList=new ArrayList<Map<String,Object>>();
        adapter=new SimpleAdapter(this, getData(), R.layout.item, new String[]{"pic","name"}, new int[]{R.id.pic,R.id.name});
        gridView.setAdapter(adapter);
	}

	private List<Map<String, Object>> getData() {
		int[] drawable = { R.drawable.address_book, R.drawable.calendar,
				R.drawable.camera, R.drawable.clock, R.drawable.games_control,
				R.drawable.messenger, R.drawable.ringtone, R.drawable.settings,
				R.drawable.speech_balloon, R.drawable.weather,
				R.drawable.world, R.drawable.youtube };
		String[] iconName = { "联系人", "日历", "照相机", "时钟", "游戏", "短信", "铃声", "设置","语音", "天气", "浏览器", "Youtube" };
		for (int i = 0; i < drawable.length; i++) {
			Map<String, Object> map = new HashMap<String, Object>();
			map.put("pic", drawable[i]);
			map.put("name", iconName[i]);
            dataList.add(map);
		}
		return dataList;
	}
}
```

## 十五、Spinner   
- 作用：实现下拉列表   
- 实现过程   
1.设置数据源 List<String>或者List<Map<String,Object>>   
2.新建适配器 ArrayAdapter<String>或者SimpleAdapter    
3.adapter设置一个下拉列表样式 adapter.setDropDownViewResource(resourse);   
4.spinner加载适配器 spinner.setAdapter(adapter);   
5.为spinner设定监听器 spinner.setOnItemSelectedListener(new spinner.OnItemSelectedListener(){@Override @Override });   
- 示例1:   
```java
public class MainActivity extends Activity  {

	private List<String> list = new ArrayList<String>();
	private TextView myTextView;
	private Spinner mySpinner;
	private ArrayAdapter<String> adapter;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.main);
		// 第一步：添加一个下拉列表项的list，这里添加的项就是下拉列表的菜单项
		list.add("北京");
		list.add("上海");
		list.add("广州");
		list.add("深圳");
		myTextView = (TextView) findViewById(R.id.textView);
		mySpinner = (Spinner) findViewById(R.id.spinner);
		// 第二步：为下拉列表定义一个适配器，这里就用到里前面定义的list。
		adapter = new ArrayAdapter<String>(this,
				android.R.layout.simple_spinner_item, list);
		// 第三步：为适配器设置下拉列表下拉时的菜单样式。
		adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
		// 第四步：将适配器添加到下拉列表上
		mySpinner.setAdapter(adapter);
		// 第五步：为下拉列表设置各种事件的响应，这个事响应菜单被选中
		mySpinner.setOnItemSelectedListener(new Spinner.OnItemSelectedListener() {
					public void onItemSelected(AdapterView<?> arg0, View arg1,
							int arg2, long arg3) {
						// TODO Auto-generated method stub
						/* 将所选mySpinner 的值带入myTextView 中 */
						myTextView.setText("您选择的是：" + adapter.getItem(arg2));
					}
				});
	}
}
```
- 示例2：   
```java
public class MainActivity extends Activity{
	private TextView myTextView;
	private Spinner mySpinner;
	private SimpleAdapter adapter;
	private List<Map<String, Object>> dataList;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.main);
		// 第一步：添加一个下拉列表项的list，这里添加的项就是下拉列表的菜单项
		dataList = new ArrayList<Map<String, Object>>();
		getData();
		myTextView = (TextView) findViewById(R.id.textView);
		mySpinner = (Spinner) findViewById(R.id.spinner);
		// 第二步：为下拉列表定义一个适配器，这里就用到里前面定义的list。
		adapter=new SimpleAdapter(this, dataList, R.layout.item, new String[]{"image","text"}, new int[]{R.id.image,R.id.text});
		
		// 第三步：为适配器设置下拉列表下拉时的菜单样式。
		adapter.setDropDownViewResource(R.layout.item);
		// 第四步：将适配器添加到下拉列表上
		mySpinner.setAdapter(adapter);
		// 第五步：为下拉列表设置各种事件的响应，这个事响应菜单被选中
		mySpinner.setOnItemSelectedListener(new Spinner.OnItemSelectedListener() {
					public void onItemSelected(AdapterView<?> arg0, View arg1,
							int arg2, long arg3) {
						// TODO Auto-generated method stub
						/* 将所选mySpinner 的值带入myTextView 中 */
						myTextView.setText("您选择的是：" + adapter.getItem(arg2));
					}
		});

    }
    private void getData() {
		// TODO Auto-generated method stub
		Map<String, Object> map = new HashMap<String, Object>();
		map.put("image", R.drawable.ic_launcher);
		map.put("text", "北京");
		Map<String, Object> map2 = new HashMap<String, Object>();
		map2.put("image", R.drawable.ic_launcher);
		map2.put("text", "上海");
		Map<String, Object> map3 = new HashMap<String, Object>();
		map3.put("image", R.drawable.ic_launcher);
		map3.put("text", "广州");
		Map<String, Object> map4 = new HashMap<String, Object>();
		map4.put("image", R.drawable.ic_launcher);
		map4.put("text", "深圳");
		dataList.add(map);
		dataList.add(map2);
		dataList.add(map3);
		dataList.add(map4);
	}
}
```   

## 十六、ProgressBar的显示风格  
- ProgressBar的显示风格   
大的环形progressBar: style="?android:attr/progressBarStyleLarge"   
中的环形progressBar: style不设置    
小的环形progressBar： style="?android:attr/progressBarStyleSmall"    
水平progressBar： style="?android:attr/progressBarStyleHorizontal"   
- 在标题栏上设置ProgreessBar   
1.启用窗口特征：在标题栏上启用带进度的和不带进度的进度条   
requestWindowFeature（Window.FEATURE_PROGRESS）;   
requestWindowFeature（Window.FEATURE_INDETERMINATE_PROGRESS）;     
2.显示两种进度条   
setProgreessBarVisibility(ture);   
setProgreessBarIndeterminateVisibility(true);   
setProgree(600)；（设置进度条的进度，最大MAX=10000）   
- ProgressBar的关键属性    
android:max = “100” ——最大显示进度    
android:progress = “50” ——第一显示进度    
android:secondaryProgress = “80” —— 第二显示进度    
android:indeterminate = “true” —— 设置是否精确显示（★注：true表示不精确显示，false表示精确显示进度）   
- ProgressBar的关键方法    
2、setSecondaryProgress(int) 设置第二进度       
3、getProgress( ) 获取第一进度    
4、getSecondaryProgress( ) 获取第二进度    
5、incrementProgressBy(int) 增加或减少第一进度   
6、incrementSecondaryProgressBy(int) 增加或减少第二进度    
7、getMax( )获取最大进度   
- 进度条对话框  
```java
//新建progressDialog对象
ProgreddDialog proDialog=new ProgressDialog(MainActivity.this);
//设置显示风格
proDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
//设置标题
proDialog.setTitle("标题");
//设置对话框里的文字信息
proDialog.setMessage("欢迎大家");
//设置图标
proDialog.setIcon(R.drawable.ic_launcher);
//设置最大进度
proDialog.setMax(100);
//设定初始化已经增长了的进度
proDialog.incrementProgressBy(40);
//指定进度条是明确显示进度的
proDialog.setIndeterminate(false);
//设定一个确认按钮
//proDialog.setButton(whichButton, text, listener);
proDialog.setButton(DialogInterface.BUTTON_POSITIVE,"确定", new DialogInterface.OnClickListener() {
	@Override
	public void onClick(DialogInterface dialog, int witch) {
	Toast.makeText(MainActivity.this, "再见",Toast.LENGTH_SHORT).show();
	}
});
//是否可以通过返回按钮退出对话框
proDialog.setCancelable(true);
//把progressDialog显示出来
proDialog.show();
```   
- 示例：    
```java
public class MainActivity extends Activity implements OnClickListener {
	private ProgressBar progress;
	private Button add;
	private Button reduce;
	private Button reset;
	private TextView text;
    private ProgressDialog prodialog;
	private Button show;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		// 启用窗口特征，启用带进度和不带进度的进度条
		requestWindowFeature(Window.FEATURE_PROGRESS);
		requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
		setContentView(R.layout.main);
		// 显示两种进度条
		setProgressBarVisibility(true);
		setProgressBarIndeterminateVisibility(false);
		// Max=10000
		setProgress(9999);
		init();
	}
	private void init() {
		// TODO Auto-generated method stub
		progress = (ProgressBar) findViewById(R.id.horiz);
		add = (Button) findViewById(R.id.add);
		reduce = (Button) findViewById(R.id.reduce);
		reset = (Button) findViewById(R.id.reset);
		text = (TextView) findViewById(R.id.text);
		show=(Button) findViewById(R.id.show);
		show.setOnClickListener(this);
		// 获取第一进度条的进度
		int first = progress.getProgress();
		// 获取第二进度条的进度
		int second = progress.getSecondaryProgress();
		// 获取进度条的最大进度
		int max = progress.getMax();
		text.setText("第一进度百分比：" + (int) (first / (float) max * 100)
				+ "% 第二进度百分比：" + (int) (second / (float) max * 100) + "%");
		add.setOnClickListener(this);
		reduce.setOnClickListener(this);
		reset.setOnClickListener(this);
	}
	@Override
	public void onClick(View v) {
		// TODO Auto-generated method stub
		switch (v.getId()) {
		case R.id.add: {
			// 增加第一进度和第二进度10个刻度
			progress.incrementProgressBy(10);
			progress.incrementSecondaryProgressBy(10);
			break;
		}
		case R.id.reduce: {
			// 减少第一进度和第二进度10个刻度
			progress.incrementProgressBy(-10);
			progress.incrementSecondaryProgressBy(-10);

			break;
		}
		case R.id.reset: {
			progress.setProgress(50);
			progress.setSecondaryProgress(80);
			break;
		}
		
		case R.id.show:
		{
			
			/**
			 * 页面显示风格
			 */
			//新建ProgressDialog对象
			prodialog=new ProgressDialog(MainActivity.this);
			//设置显示风格
			prodialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
			//设置标题
			prodialog.setTitle("标题");
			//设置对话框里的文字信息
			prodialog.setMessage("欢迎大家");
			//设置图标
			prodialog.setIcon(R.drawable.ic_launcher);
			/**
			 * 设定关于ProgressBar的一些属性
			 */
			//设定最大进度
			prodialog.setMax(100);
			//设定初始化已经增长到的进度
			prodialog.incrementProgressBy(50);
			//进度条是明确显示进度的
			prodialog.setIndeterminate(false);
			
			/**
			 * 设定一个确定按钮
			 */
			prodialog.setButton(DialogInterface.BUTTON_POSITIVE, "确定", new DialogInterface.OnClickListener() {
				
				@Override
				public void onClick(DialogInterface dialog, int which) {
					// TODO Auto-generated method stub
					Toast.makeText(MainActivity.this, "再见", Toast.LENGTH_SHORT).show();
				}
			});
			
			//是否可以通过返回按钮退出对话框
			prodialog.setCancelable(true);
			//显示ProgressDialog
			prodialog.show();
			
			break;
		}
		
		}
		text.setText("第一进度百分比："+ (int) (progress.getProgress() / (float) progress.getMax() * 100)+ "% 第二进度百分比："+ (int) (progress.getSecondaryProgress()/ (float) progress.getMax() * 100) + "%");
	}
}
```   

## 十七、WebView    
- 不使用WebView，调用浏览器，打开网址代码   
```java
Uri uri=Uri.parse("http://www.baidu.com");
Intent intent=new Intent(Intent.ACTION_VIEW, uri);
startActivity(intent);
```
- 常用属性（按照下列方法这样还是调用浏览器）  
1.webView.loadUrl("http://www.baidu.com");
2.webView.requestFocus();//获取焦点
3.载入本地资源webView.loadUrl("file:///android_asset/example.html");
4.权限配置：设置网络访问权限`<uses-permission android:name="android.permission.INTERNET"/>`   
- 覆盖打开网页的行为：   
```java
//覆盖webView默认通过默认浏览器或是第三方浏览器开网页的行为，使网页可以在WebView中打开
//返回值时true的时候控制网页在WebView中去打开，如果为false调用系统浏览器或第三方浏览器
//WebViewClient帮助WebView去处理一些页面控制和请求通知
webView.loadUrl("http://www.baidu.com");
webView.setWebViewClient(new WebViewClient(){
	@Override
	public boolean shouldOverrideUrlLoading(WebView view,String url){
	view.loadUrl(url);
	return true;
	}
});
```   
- 启用支持JavaScript   
```java
WebSettings websettings=webView.getSettings();
websettings.setJavaScriptEnabled(true);
```
- webview中网页的前进与后退  
```java
//改写物理按键的逻辑
public boolean onKeyDown(int keyCode,keyEvent event ){
	if(keyCode==keyEvent.KEYCODE_BACK){           //如果按下的按钮等于“返回键”
		if(webview.canGoBack()){
			webview.goBack();			//返回上一个页面
			return true;
		} else{
		System.exit(0);					//退出程序
		}
	｝
}
```   
- 判断页面加载过程:   
由于有些网页可能加载缓慢，所以我们需要去判断页面的加载过程，制作进度条给予用户良好的体验效果  
```java
webView.setWebChromeClient(new WebChromeClient(){
	@Overrid
	public void onProgressChanged(WebView view,int new Progress){
		if(newProgress==100){
			//加载完成
		}
		else{
			//加载中
		}
	}
}）;
```
- WebView缓存的运用:   
优先使用缓存：    
webView.getSettings().setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);   
不用缓存：   
webView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);   
- 示例：   
```java
public class MainActivity extends Activity {
	private String url = "http://2014.qq.com/";
	private WebView webView;
    private ProgressDialog dialog;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.web);
		// Uri uri = Uri.parse(url); //url为你要链接的地址
		// Intent intent =new Intent(Intent.ACTION_VIEW, uri);
		// startActivity(intent);
		init();
	}
	private void init() {
		// TODO Auto-generated method stub
		webView = (WebView) findViewById(R.id.webView);
		// WebView加载本地资源
		// webView.loadUrl("file:///android_asset/example.html");
		// WebView加载web资源
		webView.loadUrl(url);
		// 覆盖WebView默认通过第三方或者是系统浏览器打开网页的行为，使得网页可以在WebVIew中打开
		webView.setWebViewClient(new WebViewClient(){
			@Override
			public boolean shouldOverrideUrlLoading(WebView view, String url) {
				// TODO Auto-generated method stub
				//返回值是true的时候控制网页在WebView中去打开，如果为false调用系统浏览器或第三方浏览器去打开
				view.loadUrl(url);
				return true;
			}
			//WebViewClient帮助WebView去处理一些页面控制和请求通知
		});
		//启用支持JavaScript
		WebSettings settings = webView.getSettings();
		settings.setJavaScriptEnabled(true);
		//WebView加载页面优先使用缓存加载
		settings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);
		webView.setWebChromeClient(new WebChromeClient(){
			@Override
			public void onProgressChanged(WebView view, int newProgress) {
				// TODO Auto-generated method stub
                //newProgress 1-100之间的整数
				if(newProgress==100)
				{
					//网页加载完毕，关闭ProgressDialog
					closeDialog();
				}
				else
				{
					//网页正在加载,打开ProgressDialog
					openDialog(newProgress);
				}
			}
			private void closeDialog() {
				// TODO Auto-generated method stub
                  if(dialog!=null&&dialog.isShowing())
                  {
                	     dialog.dismiss();
                	     dialog=null;
                  }
			}
			private void openDialog(int newProgress) {
				// TODO Auto-generated method stub
				if(dialog==null)
				{
					dialog=new ProgressDialog(MainActivity.this);
					dialog.setTitle("正在加载");
					dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
					dialog.setProgress(newProgress);
					dialog.show();
				}
				else
				{
					dialog.setProgress(newProgress);
				}
			}
		});
	}
	//改写物理按键——返回的逻辑
	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event) {
		// TODO Auto-generated method stub
		if(keyCode==KeyEvent.KEYCODE_BACK)
		{
			//Toast.makeText(this, webView.getUrl(), Toast.LENGTH_SHORT).show();
			if(webView.canGoBack())
			{
				webView.goBack();//返回上一页面
				return true;
			}
			else
			{
				System.exit(0);//退出程序
			}
		}
		return super.onKeyDown(keyCode, event);
	}
}
```  

## 十八、Fragment  
#### 一.静态加载Fragment   
- Activity中包含一个Fragment  
在Activity中包含一个Fragment，首先要在Activity的布局文件中声明一个<Fragment>,在这个Fragment标签中，必须要有id和一个android：name属性（这个name的属性是定义的MyFragment类名）。要使用Fragment，就要定义一个Fragment的类，比如叫做“MyFragment”,这个类必须继承Fragment类。在这个类的onCreateView方法中，规定Fragment的xml文件，然后写Fragment的xml文件。  
- onCreateView()方法   
Fragment第一次绘制它的用户界面的时候，系统会调用此方法，为了绘制Fragment的UI，此方法必须返回一个View，如果不显示UI，返回null即可。   
- 一个Activity中有Fragment，这个Fragment中的button、textview等控件，可以在该Activity中通过findViewById找到并使用。      
```java
public class MyFragment2 extends Fragment{	
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container,
			Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		//layout布局文件转换成View对象		
		/**
		 * resource:Fragment需要加载的布局文件
		 * root：加载layout的父ViewGroup
		 * attactToRoot：false，不返回父ViewGroup
		 */
		View view = inflater.inflate(R.layout.fragment, container, false);
		TextView text=(TextView) view.findViewById(R.id.text);
		text.setText("动态加载Fragment");
		return view;
	}
}
```

#### 二.动态加载Fragment   
- 定义一个Fragment的类，比如叫做“MyFragment2”,这个类必须继承Fragment类。在这个类的onCreateView方法中，规定Fragment的xml文件，然后写Fragment的xml文件。   
```java
// 实例化类
MyFragment2 fragment2 = new MyFragment2();
// 获得Fragment的管理者
FragmentManager fragmentManager = getFragmentManager();
// 通过管理者（FragmentManager fragmentManager）开启事务
FragmentTransaction beginTransaction = fragmentManager.beginTransaction();
// 执行一个添加的变化：（还有移除:remove 和 替换：replace）
beginTransaction.add(R.id.frame, fragment2); //把第二个参数放到第一个参数里
// 物理按键back可以返回上一层
beginTransaction.addToBackStack(null);
// 提交事物（FragmentTransaction beginTransaction）给Activity
beginTransaction.commit();
```

#### 三、Fragment生命周期     
1、 onAttach();//当fragment被添加到activity中时会回调这个方法；只会调用一次  
2、 onCreate();//在fragment创建的时候回调这个方法；只会调用一次；  
3、 onCreateView()://每次创建都会绘制Fragment的View组件时调用该方法,相当于fragment绑定一个布局，布局文件转换成view返回回来；   
4、 onActivityCreated();//fragment所在的activity启动完成后调用；  
5、 onStart():启动Fragment时会被回调,   
6、 onResume()方法，调用onStart()方法后面一定会调用这个方法，恢复fragment时回调   
7、 onPause():暂停Fragment   
8、 onStop();//停止Fragment   
9、 onDestroyView():销毁Fragment所包含的View组件，与onCreateView相对应   
10、 onDestroy():销毁Fragment时会被回调      
11、 onDetach():Fragment从Activity中删除时回调这个方法，并且只调用一次   
- 启动fragment    
onAttach()->onCreate()->onCreateView()->onActivityCreated()->onStart()->onResume()   
- 屏幕锁屏    
onPause()->onStop()   
- 屏幕解锁   
onStart()->onResume()   
- 第一个fragment切换到第二个fragment   
1.第一个onPause()->onStop()->onDestoryView()->onDestory()->onDetach();  
2.第二个onAttach()->onCreate()->onCreateView()->onActivityCreated()->onStart()->onResume()   

#### 四、activity向fragment传递数据   
```java
Activity类中主要代码
button.setOnClickListener(new OnClickListener() {
	public void onClick(View arg0) {
	String text = edittext.getText().toString();//获取编辑框输入的内容
	MyFragment3 myfragment3 = new MyFragment3();//new一个fragment对象
	Bundle bundle = new Bundle();
	bundle.putString("name", text);
	myfragment3.setArguments(bundle);//bundle传入数据
	//下面是动态启动fragment
	FragmentManager fragmentManager = getFragmentManager();
	FragmentTransaction beginTransaction = fragmentManager.beginTransaction();
	beginTransaction.add(R.id.three, myfragment3, "fragment_xxx");
	beginTransaction.commit();
	Toast.makeText(ThreeActivity.this,"向fragment发送数据"+text,Toast.LENGTH_SHORT).show();    //打印toast不要忘记show出来
	}
});
Fragment类中部分主要代码
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container,
			Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		View view = inflater.inflate(R.layout.fragment2, container, false);
		TextView tv = (TextView) view.findViewById(R.id.text);
		String text=getArguments().get("name")+"";   //接收activity传递过来的数据
        tv.setText(text);
		return view;
	}
```  
#### 五、Fragment向Activity传递数据  
###### 动态  
```java
public class MyFragment5 extends Fragment{
	private String code="Thank you,Activity!";
	public MyListener listener;
	public interface MyListener
	{
		public void thank(String code);
	}
	@Override
	public void onAttach(Activity activity) {
		// TODO Auto-generated method stub	
		listener=(MyListener) activity;
		super.onAttach(activity);
	}
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container,
			Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		View view = inflater.inflate(R.layout.fragment2, container, false);
		TextView tv = (TextView) view.findViewById(R.id.text);
		String text=getArguments().get("name")+"";
        tv.setText(text);
		Toast.makeText(getActivity(), "已成功接收到"+text, Toast.LENGTH_SHORT).show();
		Toast.makeText(getActivity(), "向Activity发送"+code, Toast.LENGTH_SHORT).show();
		listener.thank(code);
		return view;
	}
}
```   
1. 在Fragment内部定义一个接口，然后在Activity中实现这个接口中的方法。那么相当于这个Activity是接口的子类。  
2. Fragment的onAttach方法可以获取与之关联的Activity，实例化该接口的一个对象，并把Activity向上转型给该对象。  
3. 该对象执行接口里面的方法，就相当于执行Activity里实现的方法。   

###### 静态   
1. Activity的布局文件中有Fragment，通过以下方法获取该Fragment。  
```java
//onCreat()方法内
FragmentManager fragmentManager = getFragmentManager();
Fragment findFragmentById = fragmentManager.findFragmentById(R.id.frag);
MyFragment frag=(MyFragment) findFragmentById;
frag.setAaa("fragment静态传值");    //Fragment中的一个设置方法。
```
2. Fragment类：  
```java
public class MyFragment extends Fragment{
	private String aaa;
	public String getAaa() {
		return aaa;
	}
	public void setAaa(String aaa) {
		this.aaa = aaa;
	}
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container,
			Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		//layout布局文件转换成View对象
		/**
		 * resource:Fragment需要加载的布局文件
		 * root：加载layout的父ViewGroup
		 * attactToRoot：false，不返回父ViewGroup
		 */
		View view = inflater.inflate(R.layout.fragment, container, false);
		TextView text=(TextView) view.findViewById(R.id.text);
		Button button=(Button) view.findViewById(R.id.button);
		text.setText("静态加载Fragment");
		button.setText("获取内容");
		button.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				String value = getAaa();
				Toast.makeText(getActivity(), "value="+value, Toast.LENGTH_SHORT).show();
			}
		});
		return view;
	}
}
```

## 十九、ViewPager  
1. 加入ViewPager:   
使用`<android.support.v4.view.ViewPager>···</android.support.v4.view.ViewPager>`组件  
2. 加载显示的页卡，将Layout布局转换为View对象   
（1）.LayoutInflater lf=getLayoutInflater().from(this);   
lf.inflate(resource,root);   
（2）.View.inflate(context,resource,root);    
3.	配置Adapter    
（1）	PagerAdapter 数据源：`List<View>;`    
（2）	FragmentPagerAdapter 数据源：`List<Fragment>;`    
（3）	FragmentStatePagerAdapter 数据源：`List<Fragment>;`    
4. PagerAdapter步骤：  
第一步：新建多个view1，view2，3，4.xml文件   
第二步：在MainActivity中view1，2，3，4转为View对象。`View view1 = View.inflate(this, R.layout.view1, null);`     
第三步：声明并初始化数据源`private List<View>viewList;` `viewList=new ArrayList<View>();`    
第四步 把多个布局文件放在数据源集合viewList.add(view1);    
第五步 新建类MyPagerAdapter 继承PagerAdapter   
```java
public class MyViewPagerAdapter extends PagerAdapter{
	private List<View>viewList;
	private List<String>titleList;
	public MyViewPagerAdapter(List<View>viewList)
	{
		this.viewList=viewList;
	}
	//返回所有视图的数量
	@Override
	public int getCount() {
		// TODO Auto-generated method stub
		return viewList.size();
	}
	//判断视图是否由对象产生
	@Override
	public boolean isViewFromObject(View arg0, Object arg1) {
		// TODO Auto-generated method stub
		return arg0==arg1;
	}
	//实例化页卡
    @Override
    public Object instantiateItem(ViewGroup container, int position) {
    	// TODO Auto-generated method stub
    	container.addView(viewList.get(position));
    	return viewList.get(position);
    }
    //删除页卡
    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {
    	// TODO Auto-generated method stub
    	container.removeView(viewList.get(position));
    }
}
```
第六步：回到MainActivity中，实例化一个MyViewPagerAdapter适配器。`MyViewPagerAdapter adapter=new MyViewPagerAdapter(viewList);`   
第七步：在MainActivity中，声明ViewPager。`private ViewPager pager;` `pager=(ViewPager) findViewById(R.id.pager);`     
第八步：给ViewPager加载适配器`pager.setAdapter(adapter);`    
5. 加标题  
1.布局文件加入  
```xml
<android.support.v4.view.PagerTabStrip
       android:id="@+id/tab"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content" >
</android.support.v4.view.PagerTabStrip>
```
2.MainActivity中声明`private PagerTabStrip tab;`   
3.创建一个放标题的List`private List<String> titleList;`   
4.实例化titleList`titleList = new ArrayList<String>();`    
5.往titleList中放各个标题`titleList.add("第一页");···`   
6.重写构造方法`MyViewPagerAdapter adapter=new MyViewPagerAdapter(viewList,titleList);`
7.在MyViewPagerAdaper中重写构造方法   
```java
public MyViewPagerAdapter(List<View>viewList,List<String>titleList)
	{
		this.viewList=viewList;
		this.titleList=titleList;
	}
```
8.MyViewPagerAdapter类中加入方法   
```java
@Override
    public CharSequence getPageTitle(int position) {
    	// TODO Auto-generated method stub
    	return titleList.get(position);
    }
```   
9.设置样式  
```
		tab=(PagerTabStrip) findViewById(R.id.tab);
		tab.setBackgroundColor(Color.YELLOW);
		tab.setTabIndicatorColor(Color.BLUE);
		tab.setDrawFullUnderline(false);
		tab.setTextColor(Color.RED);
```
10.PagerTitleStrip与之相似   
6. FragmentPagerAdapter   
第一步：新建多个Fragment1，2，3，4类文件   
```java
public class Fragment1 extends Fragment{

	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container,
			Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		return inflater.inflate(R.layout.view1, container, false);
	}
}
```     
第三步：声明并初始化数据源`private List<Fragment>fragList;` `fragList=new ArrayList<Fragment>();`    
第四步 把多个Fragment放在数据源集合fragList.add(new Fragment1());    
第五步 新建类MyFragmentPagerAdapter 继承FragmentPagerAdapter   
```java
public class MyFragmentPagerAdapter extends FragmentPagerAdapter{
	private List<Fragment>fragList;
	private List<String>titleList;
	public MyFragmentPagerAdapter(FragmentManager fm,List<Fragment> fragList,List<String>titleList) {
		super(fm);
		// TODO Auto-generated constructor stub
		this.fragList=fragList;
		this.titleList=titleList;
	}
	@Override
	public Fragment getItem(int arg0) {
		// TODO Auto-generated method stub
		return fragList.get(arg0);
	}
	@Override
	public int getCount() {
		// TODO Auto-generated method stub
		return fragList.size();
	}
	@Override
	public CharSequence getPageTitle(int position) {
		// TODO Auto-generated method stub
		return titleList.get(position);
	}
}
```
第六步：回到MainActivity中，实例化一个MyFragmentPagerAdapter适配器。`MyFragmentPagerAdapter adapter=new MyFragmentPagerAdapter(viewList);`   
第七步：在MainActivity中，声明ViewPager。`private ViewPager pager;` `pager=(ViewPager) findViewById(R.id.pager);`     
第八步：给ViewPager加载适配器`pager.setAdapter(adapter);`    
7. 监听接口  
1.MainActivity继承OnPageChangeListener接口。   
2.ViewPager的实例 pager.setOnPageChangeListener(this);   
3.重写   
```java
@Override
	public void onPageSelected(int arg0) {
		// TODO Auto-generated method stub
		Toast.makeText(this, "这是第"+(arg0+1)+"个界面", Toast.LENGTH_SHORT).show();
	}
```

## 二十、ViewFlipper  
说明：PagerView是用于手动的左右滑动；ViewFlipper大多用于自动的左右转场，也可用于手动左右切换。  
- 自动切换之静态加载  
该方法直接把图片资源在布局文件中进行加载(不推荐使用)   
```xml
<ViewFlipper
        android:id="@+id/flipper"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:flipInterval="4000">
        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:src="@mipmap/ic_launcher1"/>
        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:src="@mipmap/ic_launcher2"/>
        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:src="@mipmap/ic_launcher3"/>
        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:src="@mipmap/ic_launcher4"/>
    </ViewFlipper>
```
- 自动切换之动态加载  
xml文件：   
```xml
<ViewFlipper 
    android:id="@+id/flipper"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    ></ViewFlipper>
```
Mainctivity:   
```java
public class MainActivity extends ActionBarActivity {
	private ViewFlipper flipper;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.main);
		flipper = (ViewFlipper) findViewById(R.id.flipper);
		flipper.addView(getImageView(R.drawable.pic1));
		flipper.addView(getImageView(R.drawable.pic2));
		flipper.addView(getImageView(R.drawable.pic3));
		flipper.addView(getImageView(R.drawable.pic4));
		flipper.setBackgroundColor(Color.BLACK);
		flipper.setFlipInterval(5000);     //切换间隔
		flipper.setInAnimation(this, R.anim.anim_in);    //进入动画
		flipper.setOutAnimation(this, R.anim.anim_out);      //消失动画
		flipper.startFlipping();     //开始
	}
	private ImageView getImageView(int resId) {
		ImageView image = new ImageView(this);
		image.setBackgroundResource(resId);
		return image;
	}
}
```  
- 手动切换  
```java
public class MainActivity extends ActionBarActivity {

	private ViewFlipper flipper;
    private float startX;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.main);
		flipper = (ViewFlipper) findViewById(R.id.flipper);
		flipper.addView(getImageView(R.drawable.pic1));
		flipper.addView(getImageView(R.drawable.pic2));
		flipper.addView(getImageView(R.drawable.pic3));
		flipper.addView(getImageView(R.drawable.pic4));
		flipper.setBackgroundColor(Color.BLACK);
	}
	private ImageView getImageView(int resId) {
		ImageView image = new ImageView(this);
		image.setBackgroundResource(resId);
		return image;
	}
	@Override
	public boolean onTouchEvent(MotionEvent event) {
		// TODO Auto-generated method stub
		switch (event.getAction()) {
		case MotionEvent.ACTION_DOWN: {
			//手指落下
			startX=event.getX();
			break;
		}
		case MotionEvent.ACTION_UP:
		{
			//向右滑动
			if(event.getX()-startX>50)
			{
				 flipper.setInAnimation(this, R.anim.left_in);
				 flipper.setOutAnimation(this, R.anim.left_out);
				 flipper.showNext();
			}
			//向左滑动
			if(startX-event.getX()>50)
			{
				 flipper.setInAnimation(this, R.anim.right_in);
				 flipper.setOutAnimation(this, R.anim.right_out);
				 flipper.showPrevious();
			}
			break;
		}
		}
		return super.onTouchEvent(event);
	}
}
```  

## 二十一、ScrollView    
- 基础  
纵向：ScrollView  
横向：HorizontalScrollView   
隐藏ScrollView：   
1、标签属性：android:scrollbars = "none"    
2、代码设置：   
setHorizontalScrollBarEnable(false);隐藏横向ScrollView    
setVerticalScrollBarEnable(false);隐藏纵向ScrollView     
- 可以为ScrollView绑定监听器OnTouchListener    
- scrollto和scrollby:scrollTo与scrollBy的区别:参考系不同，前者，以滚动视图起始位置开始计算，后者以相对前一次的位置去滚动相应的距离   
- 示例：
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    <Button
        android:id="@+id/up"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="UP" />
    <Button
        android:id="@+id/down"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="DOWN" />
    <ScrollView
        android:id="@+id/scroll"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:scrollbars="none" >
        <TextView
            android:id="@+id/content"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />
    </ScrollView>
</LinearLayout>
```
```java
public class MainActivity extends Activity implements OnClickListener{
	private TextView tv;
	private ScrollView scroll;
	private Button up_btn;
	private Button down_btn;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.main);
		tv = (TextView) findViewById(R.id.content);
		up_btn=(Button) findViewById(R.id.up);
		down_btn=(Button) findViewById(R.id.down);
		up_btn.setOnClickListener(this);
		down_btn.setOnClickListener(this);
		tv.setText(getResources().getString(R.string.content));
		scroll = (ScrollView) findViewById(R.id.scroll);
		scroll.setOnTouchListener(new OnTouchListener() {
			@Override
			public boolean onTouch(View v, MotionEvent event) {
				// TODO Auto-generated method stub
				switch (event.getAction()) {
				case MotionEvent.ACTION_MOVE: {
					/**
					 * (1)getScrollY()————滚动条滑动的距离 
					 * (2)getMeasuredHeight()————总高度
					 * (3)getHeight()————一屏高度
					 */
					// 顶部状态
					if (scroll.getScrollY() <= 0) {
						Log.i("Main", "滑动到顶部");
					}
					// 底部状态
					// TextView的总高度<=一屏幕的高度+滚动条的滚动距离
					if (scroll.getChildAt(0).getMeasuredHeight() <= scroll
							.getHeight() + scroll.getScrollY()) {
						Log.i("Main", "滑动到底部");
						Log.i("Main",
								"scroll.getChildAt(0).getMeasuredHeight()="
										+ scroll.getChildAt(0)
												.getMeasuredHeight()
										+ "scroll,getHeight()="
										+ scroll.getHeight()
										+ "scroll.getScrollY()="
										+ scroll.getScrollY());
						tv.append(getResources().getString(R.string.content));
					}
					break;
				}
				}
				return false;
			}
		});
	}
	@Override
	public void onClick(View v) {
		// TODO Auto-generated method stub
		switch(v.getId())
		{
		//scrollTo：以滚动视图起始位置开始计算的
		//scrollBy：相对前一次的位置，去滚动对应的距离
		case R.id.up:
		{	
			scroll.scrollBy(0, -30);
			break;
		}
		case R.id.down:
		{
			scroll.scrollBy(0, 30);
			break;
		}
		}
	}
}
```  

## 二十二、SeekBar  
SeekBar是ProgressBar的子类。通过滑块的位置来标识数值，而且拖动条允许用户拖动滑块来改变进度值的大小。   
- 主要属性和方法    
setMax()——设置SeekBar的最大数值  
setProgress()——设置SeekBar当前的数值   
setSecondaryProgress()——设置SeekBar的第二数值    
- SeekBar与ProgressBar最大的区别就是进度可以由用户控制。所以需要对其进行事件监听，这就需要实现OnSeekBarChangeListener接口    
(1)onProgressChanged()——数值改变   
(2)onStartTrackingTouch()——开始拖动   
(3)onStopTrackingTouch()——停止拖动   
- 示例  
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >
    <SeekBar
        
        android:thumb="@drawable/my_thumb"
        android:id="@+id/seekBar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:max="100"
        android:progress="50" />
    <TextView
        android:id="@+id/tv1"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
    <TextView
        android:id="@+id/tv2"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
</LinearLayout>
```
```java
public class MainActivity extends Activity implements OnSeekBarChangeListener{
	private SeekBar seekBar;
	private TextView tv1;
	private TextView tv2;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.main);
        seekBar=(SeekBar) findViewById(R.id.seekBar);
        tv1=(TextView) findViewById(R.id.tv1);
        tv2=(TextView) findViewById(R.id.tv2);
        seekBar.setOnSeekBarChangeListener(this);
	}
	//数值改变
	@Override
	public void onProgressChanged(SeekBar seekBar, int progress,
			boolean fromUser) {
		// TODO Auto-generated method stub
		tv1.setText("正在拖动");
		tv2.setText("当前数值："+progress);
	}
	//开始拖动
	@Override
	public void onStartTrackingTouch(SeekBar seekBar) {
		// TODO Auto-generated method stub
		tv1.setText("开始拖动");
	}
	//停止拖动
	@Override
	public void onStopTrackingTouch(SeekBar seekBar) {
		// TODO Auto-generated method stub
		tv1.setText("停止拖动");
	}
}
```